# 硬件端口
### 1. 60h-64h
##### Intel 8042 Keyboard/Auxiliary Device Controller
##### 英特尔键盘/辅助设备控制器
a. A20GATE
键盘控制器8042在接收到命令后将它的P21引脚（输出端口P2）置高电平。此时处理器将A20地址线和键盘控制器的这个输出端口的进行AND操作，进而控制A20地址线的打开和关闭。键盘控制器的这个引脚因此得名A20Gate

CPU通过IO端口直接与这个芯片进行通信，对应的IO端口为0x60。但向该端口写入数据的方法比较复杂，0x60是一个只读端口，不能使用IN/OUT指令直接操作0x60端口，需要涉及0x64端口。其中，0x60端口的位1用于影响A20。60h端口状态只能在64h端口状态0位=1时读取。
具体查看连接<http://www.os2site.com/sw/info/memory/ports.txt>

64h READ
| BIT | 功能 |
|:----:|:----:|
|7		|1=奇偶校验错误|
|6		|1=超时|
|5		|1=辅助输出缓冲已满|
|4		|1=约束交换|
|3		|1=指令/数据|
|2		|1=系统标志位|
|1		|1=输入缓冲已满|
|0		|1=输出缓冲已满|
### 2. 92h
##### ALT_A20_GATE
除了端口号0x60可以影响A20寻址，端口0x92也用于A20寻址，被称作“替代的A20门控制”
其中，0x92端口的位0用于计算机重启，位1用于影响A20地址线。与0x60不同，0x92可以直接使用IN/OUT指令进行修改，方便快捷，因此也被称作Fast A20。0x60和0x92的位1进行或运算后连接到A20M#引脚，用于控制A20地址线的开启和关闭

# 要点信息
1. A20的开启会对实模式和保护模式的下寻址产生影响影响，以下讨论均基于Intel 80386之后的处理器

在实模式下，处理器的寻址仅涉及CS和IP两个寄存器，即CS<<4+IP，对应的线性地址为0h-10ffefh。当A20地址线处于关闭状态时，A20强制置0，此时实际寻址范围为0h-fffffh。但当A20处于打开状态，A20可以接受来自A19的进位，此时实际寻址范围为0h-10ffefh

1. GDT表项格式：(大端序要反转)
   <https://blog.csdn.net/qq_43098197/article/details/127161848>

   IDT表项格式
   <https://zhuanlan.zhihu.com/p/400007642>

2. 在保护模式下，CS寄存器不能直接通过MOV指令进行操作。
   在保护模式下，要修改CS寄存器的值，需要使用特殊的指令，如LJMP（长跳转）或LRET（长返回）。这些指令会将新的代码段选择子加载到CS寄存器中，并跳转到指定的地址。

3. 在保护模式下，处理器寻址是基于段选择子和段描述符，段描述符中段基地址32bit，段限长20bit，理论最大寻址范围为0h-1000fffefh。当A20地址线处于关闭状态时，经过计算的地址的第21位被强制置0，导致处理器无法寻址MB为奇数的任何线性地址。例如，对于0x000100ab，将会被强制转换为0x000000ab。需要注意的是，该操作影响寻址的原理是影响线性地址，而不是影响虚拟地址。当然，A20处于打开状态，就没有任何影响了
   
4. 在设定完全局描述符表、打开32位后，cpu仍然是运行16位指令，需要一个长跳转ljmp重新指定cs和ip才会真正进入32位模式。在此之前可以使用32位地址，但是指令格式仍然是16位。要注意bits 32和bits 16的区别和使用
   
5. 在16位指令模式下，前缀追加66\67的指令会被执行为32位指令，反之32位模式下，有前缀的会被执行为16位指令
   
6. C语言里规定：16bit程序中，返回值保存在ax寄存器中，32bit程序中，返回值保持在eax寄存器中，如果是64bit返回值，edx寄存器保存高32bit，eax寄存器保存低32bit。
   
# 部分指令机器码
+ | 操作码 | 指令 | 说明 |
  |:-----:|:-----:|:----|
  |0f 01/2|LGDT m16&32||
  |0f 01/3|LIDT m16&32||
# Tips
+ 对于nasm来说最好将数据段放在最后，不然会被当成代码段
+ 在没打开32位时只能使用16位（默认）编译，打开32位后的32位指令只能使用32位（bits 32）编译